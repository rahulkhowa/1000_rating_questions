             //*its rahulkhowal0803 RAHUL*//
#include<bits/stdc++.h>
using namespace std;
#define FELIX
#define ll long long int
#define trav(it, x) for (auto it = x.begin(); it != x.end(); it++)
#define f(i,a,b) for (ll i = a; i < b; i++)
#define fors(n) for(ll i=0;i<n;i++)
#define ip(v) for(ll i = 0; i < v.size(); i++) cin>>v[i];
#define show(c) cout<<c<<'\n';
#define science(a) cout<<fixed<<setpricision(0)<<a<<line;
// trav me *it krke access kro elements ko
#define pb push_back
#define eb emplace_back
#define f1 first
#define s2 second
#define all(x) x.begin(), x.end()
#define srt(x) sort(all(x))
#define line '\n'
#define mn3(x,y,z) min(min(x,y),z)
#define mx3(x,y,z) max(max(x,y),z)
#define mn4(a,b,c,d) min(min(a,b),min(c,d))
#define mx4(a,b,c,d) max(max(a,b),max(c,d))
//auto it=find(all(x),p) rhen store it in it-x.begin() me//
typedef vector<ll> vi;
typedef unordered_map<ll,ll> mii;
typedef pair<ll,ll> pii;
typedef vector<pii> vpii;
typedef vector<vector<ll>> v2ii;
const ll MOD = 1e9+7;
const ll MAXN=1e5+1;
vector<int> spf(MAXN + 1, 1);
// vector<ll> spf(MAXN + 1, 1);
// vector<ll> fact(MAXN + 1);
// vector<ll> invFact(MAXN + 1);

//modulo arithmetic

//a mod m)+(b mod m)  mod m=a+b  mod m
// (a mod m)−(b mod m)  mod m=a−b  mod m
// (a mod m)⋅(b mod m)  mod m=a⋅b  mod m

/////for factorisation help

// vi getFactorization(ll n) {
//     vi factors;
//     for (ll i = 2; i * i <= n; ++i) {
//         if (n % i == 0) {
//             factors.push_back(i);
//             if (i != n / i) {
//                 factors.push_back(n / i);
//             }
//         }
//     }
//     return factors;
// }

////////for check prime help

bool checkprime(ll n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (ll i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}

// bitwise or of range

ll rangeor(ll a,ll b){/// logic here
    ll ans=0;
    for(ll i=0;i<=31;i++){
      if((a&1ll<<i)||(b&1ll<<i)||(a>>(i+1)!=(b>>(i+1)))){
        ans|=1ll<<i;
      }
    }
    return ans;
}

/////lcm

ll lcm(ll a,ll b){
    ll k=a*1ll*b;
    return k/(__gcd(a,b));
}

// //compute xor upto n without tle

ll computeXOR(ll n) 
{ 
    
  // If n is a multiple of 4 
  if (n % 4 == 0) 
    return n; 
  
  // If n%4 gives remainder 1 
  if (n % 4 == 1) 
    return 1; 
  
  // If n%4 gives remainder 2 
  if (n % 4 == 2) 
    return n + 1; 
  
  // If n%4 gives remainder 3 
  return 0; 
} 

// // continuous sum upto n

ll csum(ll n){
    return (n*1ll*(n+1))/2;
}

bool chkpow2(ll n){
  if(!(n&(n-1))){
    return true;
  }
  return false;
}

ll lsb(ll n){
  return __builtin_ctzll(n);
}

ll msb(ll n){
  return 63-(__builtin_clzll(n));
}

ll nosetbit(ll n){
  return __builtin_popcountll(n);
}

bool chksetbit(ll n,ll i){
  if(n&(1ll<<i)){
    return true;
  }
  return false;
}

void toggle(ll &n,ll &i){
  n=n^(1ll<<i);
}

void setbit(ll &n,ll i){
  n=n|(1ll<<i);
}

void unsetbit(ll &n,ll i){
  n=n&(~(1ll<<i));
}

void clearlastbits(ll &n,ll i){
  ll mask=(-1<<i);
  n&=mask;
}

void clearrangebits(ll &n,ll i,ll j){
  ll mask=(-1<<(i+1)|~(-1<<j));
  n&=mask;
}

//longest common subsequence

long long lcs_length(const string &X, const string &Y) {
    long long m = X.length();
    long long n = Y.length();
    
    // Create a 2D array to store the lengths of LCS
    vector<vector<long long>> dp(m + 1, vector<long long>(n + 1, 0));
    
    // Fill dp array
    for (long long i = 1; i <= m; ++i) {
        for (long long j = 1; j <= n; ++j) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

//convertor static_cast<data_type>(parameter) & ceil() convert to smallest integer value
  
// to find roots of quadratic equation

long long positiveRoot(long long a, long long b, long long c) {
    long double discriminant = static_cast<long double>(b) * b - 4 * static_cast<long double>(a) * c;
    long double sqrt_discriminant = sqrt(discriminant);
    
    long double root1 = (-static_cast<long double>(b) + sqrt_discriminant) / (2 * a);
    long double root2 = (-static_cast<long double>(b) - sqrt_discriminant) / (2 * a);
    
    // Return the positive root
    if (root1 > 0 && root2 > 0) {
        return static_cast<long long>(min(root1, root2));
    } else if (root1 > 0) {
        return static_cast<long long>(root1);
    } else {
        return static_cast<long long>(root2);
    }
}

long long factorialMod(long long n) {
    // Base case
    if (n == 0 || n == 1) {
        return n;
    }
    
    // Initialize the result
    long long result = 1;

    // Compute the factorial iteratively and take modulo at each step
    for (long long i = 2; i <= n; i++) {
        result = (result * i) % MOD;
    }

    return result;
}

ll power(ll a, ll b) {
  ll x = 1;
  while (b)
  {
    if (b & 1) x *= a;
    a *= a;
    b >>= 1;
  }
  return x;
}

vi getpre(ll n,vi a){
  vi pre(n);
  pre[0]=a[0];
  for(ll i=1;i<n;i++){
    pre[i]=pre[i-1]+a[i];
  }
  return pre;
}

vi getback(ll n,vi a){
  vi back(n);
  back[0]=a[n-1];
  for(ll i=n-2;i>=0;i--){
    back[n-1-i]=back[n-i-2]+a[i];
  }
  return back;
}

ll nextPrime(ll n) {
    // Increment n until we find a prime number
    ll prime = n + 1;
    while (!checkprime(prime)) {
        prime++;
    }
    return prime;
}

vector<ll> computeLPSArray(const string &pattern) {
    ll m = pattern.length();
    vector<ll> lps(m);
    ll len = 0; // length of the previous longest prefix suffix
    lps[0] = 0; // lps[0] is always 0

    ll i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

void KMPSearch(const string &text, const string &pattern) {
    ll n = text.length();
    ll m = pattern.length();

    // Preprocess the pattern to get the LPS array
    vector<ll> lps = computeLPSArray(pattern);

    ll i = 0; // index for text
    ll j = 0; // index for pattern
    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }

        if (j == m) {
            // Pattern found at index i - j
            // cout << "Pattern found at index " << (i - j) << endl;
            // ans++;
            j = lps[j - 1];
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}

#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x <<" "; _print(x); cerr << endl;
#else
#define debug(x)
#endif
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}

 
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(unordered_set <T> v);
template <class T, class V> void _print(unordered_map <T, V> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(unordered_multiset <T> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << "{"; _print(p.f); cerr << ","; _print(p.s); cerr << "}";}
template <class T> void _print(unordered_set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(unordered_multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(unordered_map <T, V> v) {cerr << "[ "; for (auto i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(vector <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(map <T, V> v) {cerr << "[ "; for (auto i : v) {_print(i); cerr << " ";} cerr << "]";}

///////////*(i hope this time i will reach pupil(green))*/////////

void sieve()
{
    // stores smallest prime factor for every number

    spf[0] = 0;
    for (ll i = 2; i <= MAXN; i++) {
        if (spf[i] == 1) { // if the number is prime ,mark
                           // all its multiples who havent
                           // gotten their spf yet
            for (ll j = i; j <= MAXN; j += i) {
                if (spf[j]== 1) // if its smallest prime factor is
                          // 1 means its spf hasnt been
                          // found yet so change it to i
                    spf[j] = i;
            }
        }
    }
}

// A O(log n) function returning primefactorization
// by dividing by smallest prime factor at every step
vector<ll> getfactorization(ll x)
{
    vector<ll>ret;
    while (x != 1) {
        ret.push_back(spf[x]);
        x = x / spf[x];
    }
    return ret;
}

ll find_median(vi& a) {
    sort(a.begin(), a.end());
    if (a.size() % 2 == 0) {
        return (a[a.size()/2 - 1] + a[a.size()/2]) / 2;
    } else {
        return a[a.size()/2];
    }
}
ll rec(ll p,ll q,vector<vi>&dp){
   if(q==0||q==p){
     return 1;
   }
   if(dp.size()>q&&dp[p][q]!=-1){
    return dp[p][q];
   }
   if(dp.size()<=q){
     dp[p].resize(q,-1);
   }
   dp[p][q]=(rec(p,q-1,dp)+rec(p-1,q-1,dp))%MOD;
   return dp[p][q]%MOD;
}

void rahulkhowal0803() 
{
   string s;
   cin>>s;
   string ans="";
   debug(s)
   ll n=s.length();
   for(ll i=0;i<n;i++){
     if(i<n-2&&s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]){
       ans+=s[i];ans+=s[i+1];ans+=s[i+2];
       break;
     }
     else{
       if(i<n-1&&s[i]==s[i+1]){
         ans+=s[i];ans+=s[i+1];break;
       }
       else if(i<n-2&&s[i+1]==s[i+2]){
         ans+=s[i+1];ans+=s[i+2];break;
       }
     }
   }
   if(ans.empty()){
     show("-1")
   }
   else{
    show(ans)
   }
}


int main(){

  ios::sync_with_stdio(false);
  cin.tie(nullptr); cout.tie(nullptr);

  #ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.out", "w", stdout);
    freopen("error.txt", "w", stderr);
  #endif
 
  ll t;
  cin>>t;
  // sieve();
  while(t--){
    rahulkhowal0803();
  }
  // rahulkhowal0803();
  return 0;
}
